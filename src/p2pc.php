#!/usr/bin/php
<?php
$includePath=get_include_path();
$currentDirectory=dirname(__FILE__);
$newComponents=array($currentDirectory.DIRECTORY_SEPARATOR.'PhpCompiler',$currentDirectory.DIRECTORY_SEPARATOR.'PhpCompiler'.DIRECTORY_SEPARATOR.'preprocessor',$currentDirectory.DIRECTORY_SEPARATOR.'PhpCompiler'.DIRECTORY_SEPARATOR.'lexer',$currentDirectory.DIRECTORY_SEPARATOR.'PhpCompiler'.DIRECTORY_SEPARATOR.'parser',$currentDirectory.DIRECTORY_SEPARATOR.'PhpCompiler'.DIRECTORY_SEPARATOR.'symbol_table',);
set_include_path($includePath.PATH_SEPARATOR.implode(PATH_SEPARATOR,$newComponents));
assert_options(ASSERT_BAIL,1);
assert_options(ASSERT_BAIL,1);
class OA_Preprocessor{private $includePathArray;
private $ignoredFileNameArray;
private $alreadyIncludedPathArray;
private $alreadyReferencedFileNamesArray;
private $postLines;
private $lineStack;
private $fileStack;
private $lineNumberStack;
private $error;
private $currentLines;
private $currentFileName;
private $currentLineNumber;
public function __construct($includePathArray,$ignoredFileNameArray){assert(null!==$includePathArray);
assert(null!==$ignoredFileNameArray);
$this->includePathArray=$includePathArray;
$this->ignoredFileNameArray=$ignoredFileNameArray;
}public function start($inputFilePath){assert(null!==$inputFilePath);
$realInputPath=realpath($inputFilePath);
assert(false!==$realInputPath);
$this->alreadyIncludedPathArray=array();
$this->alreadyReferencedFileNamesArray=array();
$this->lineStack=array();
$this->fileStack=array();
$this->lineNumberStack=array();
$this->startingDirectory=dirname($realInputPath);
$this->currentLines=array();
$this->currentFileName='';
$this->currentLineNumber=0;
$toReturn=null;
list($preLines,$lines,$this->postLines)=$this->_loadFile($realInputPath);
if(null===$this->error){if(count($lines)>0){$this->currentLines=$lines;
$this->currentFileName=$realInputPath;
$this->currentLineNumber=count($preLines);
}$toReturn=$preLines;
}return array($toReturn,$this->error);
}public function getLine(){$line=$this->_fetchNextLine();
$lineToSet=null;
while((null===$this->error)&&(null!==$line)&&(null===$lineToSet)){$requireOnce='require_once(';
if(0===strpos($line,$requireOnce)){$endIndex=strpos($line,')');
$requireOnceLength=strlen($requireOnce)+1;
$subFileName=substr($line,$requireOnceLength,$endIndex-$requireOnceLength-1);
if(in_array($subFileName,$this->ignoredFileNameArray)){}else{$subFilePath=$this->_getRealPath($subFileName);
if(null!==$subFilePath){if(in_array($subFilePath,$this->alreadyIncludedPathArray)){}else{list($preLines,$lines,$postLines)=$this->_loadFile($subFilePath);
if(null===$this->error){if(count($lines)>0){if(count($this->currentLines)>0){array_push($this->lineStack,$this->currentLines);
array_push($this->fileStack,$this->currentFileName);
array_push($this->lineNumberStack,$this->currentLineNumber);
}$this->currentLines=$lines;
$this->currentFileName=$subFilePath;
$this->currentLineNumber=count($preLines);
}}}}else{if(in_array($subFileName,$this->alreadyReferencedFileNamesArray)){}else{$this->alreadyReferencedFileNamesArray[]=$subFileName;
$lineToSet=$line;
}}}}else{$lineToSet=$line;
}if(null===$lineToSet){$line=$this->_fetchNextLine();
}}assert(false!==$lineToSet);
return array($lineToSet,$this->currentFileName,$this->currentLineNumber,$this->error);
}public function end(){return $this->postLines;
}private function _fetchNextLine(){$nextLine=null;
if(0===count($this->currentLines)){if(count($this->lineStack)>0){$this->currentLines=array_pop($this->lineStack);
$this->currentFileName=array_pop($this->fileStack);
$this->currentLineNumber=array_pop($this->lineNumberStack);
assert(count($this->currentLines)>0);
}}if(0!==count($this->currentLines)){$nextLine=array_shift($this->currentLines);
$this->currentLineNumber+=1;
}return $nextLine;
}private function _loadFile($realPath){$this->alreadyIncludedPathArray[]=$realPath;
$lines=file($realPath);
assert(false!==$lines);
$startCount=0;
$endCount=0;
$preLines=array();
$phpLines=array();
$postLines=array();
$isPre=true;
$isPhp=false;
foreach($lines as $line){if($isPre){$preLines[]=$line;
if("<?php\n"===$line){$startCount+=1;
assert(1===$startCount);
$isPre=false;
$isPhp=true;
}}else if($isPhp){if("?>\n"===$line){$endCount+=1;
assert(1===$endCount);
$isPhp=false;
$postLines[]=$line;
}else{$phpLines[]=$line;
}}else{$postLines[]=$line;
}}if(1!==$startCount){$this->error="\"$realPath\" - Expected 1 PHP start but found $startCount";
}if(1!==$endCount){$this->error="\"$realPath\" - Expected 1 PHP end but found $endCount";
}return array($preLines,$phpLines,$postLines);
}private function _getRealPath($fileName){$realPath=realpath($fileName);
if(false===$realPath){$realPath=realpath($this->startingDirectory.DIRECTORY_SEPARATOR.$fileName);
if(false===$realPath){foreach($this->includePathArray as $path){$realPath=realpath($path.DIRECTORY_SEPARATOR.$fileName);
if(false!==$realPath){break;
}}}}return(false!==$realPath)?$realPath:null;
}}class OA_LexerNames{const kWhile='WHILE';
const kBreak='BREAK';
const kFor='FOR';
const kForeach='FOREACH';
const kIf='IF';
const kElse='ELSE';
const kSwitch='SWITCH';
const kCase='CASE';
const kDefault='DEFAULT';
const kTrue='TRUE';
const kFalse='FALSE';
const kNull='NULL';
const kPrivate='PRIVATE';
const kProtected='PROTECTED';
const kPublic='PUBLIC';
const kStatic='STATIC';
const kFunction='FUNCTION';
const kClass='CLASS';
const kAbstract='ABSTRACT';
const kInterface='INTERFACE';
const kAs='AS';
const kConst='CONST';
const kReturn='RETURN';
const kArray='ARRAY';
const kList='LIST';
const kNew='NEW';
const kExtends='EXTENDS';
const kImplements='IMPLEMENTS';
const kEcho='ECHO';
const kInstanceOf='INSTANCEOF';
const kFile='FILE';
const kDirectorySeparator='DIR_SEP';
const kPathSeparator='PATH_SEP';
const kGlobal='GLOBAL';
const kParent='PARENT';
const kNewLine='NEW_LINE';
const kOpenBrace='OPEN_BRACE';
const kCloseBrace='CLOSE_BRACE';
const kOpenParen='OPEN_PAREN';
const kCloseParen='CLOSE_PAREN';
const kOpenSquare='OPEN_SQUARE';
const kCloseSquare='CLOSE_SQUARE';
const kSemiColon='SEMI_COLON';
const kColonColon='COLON_COLON';
const kComma='COMMA';
const kCall='CALL';
const kAt='AT';
const kBitOR='BIT_OR';
const kLogicOR='LOGIC_OR';
const kOrEqual='OR_EQUAL';
const kBitAND='BIT_AND';
const kLogicAND='LOGIC_AND';
const kAndEqual='AND_EQUAL';
const kXOR='XOR';
const kNOT='NOT';
const kSlash='SLASH';
const kMinus='MINUS';
const kMinusMinus='MINUS_MINUS';
const kStar='STAR';
const kStarEqual='STAR_EQUAL';
const kPlus='PLUS';
const kPlusPlus='PLUS_PLUS';
const kPlusEqual='PLUS_EQUAL';
const kMinusEqual='MINUS_EQUAL';
const kDot='DOT';
const kDotEqual='DOT_EQUAL';
const kPercent='PERCENT';
const kEqual='EQUAL';
const kEqualEqual='EQUAL_EQUAL';
const kNotEqual='NOT_EQUAL';
const kEqualEqualEqual='EQUAL_EQUAL_EQUAL';
const kNotEqualEqual='NOT_EQUAL_EQUAL';
const kGreater='GREATER';
const kEqualGreater='EQUAL_GREATER';
const kGreaterEqual='GREATER_EQUAL';
const kLess='LESS';
const kEqualLess='EQUAL_LESS';
const kLessEqual='LESS_EQUAL';
const kQuestion='QUESTION';
const kColon='COLON';
const kIdentifier='IDENTIFIER';
const kWhiteSpace='WHITE_SPACE';
const kFloatConst='FLOAT_CONST';
const kIntConst='INT_CONST';
const kVariable='VARIABLE';
const kSingleQuoteString='SINGLE_QUOTE_STRING';
const kDoubleQuoteString='DOUBLE_QUOTE_STRING';
const kSingleComment='SINGLE_COMMENT';
const kMultiComment='MULTI_COMMENT';
const kSpecialComment='SPECIAL_COMMENT';
const kExportComment='EXPORT_COMMENT';
}class OA_LexerMaps{public static $identifierMap=array('while'=>OA_LexerNames::kWhile,'break'=>OA_LexerNames::kBreak,'for'=>OA_LexerNames::kFor,'foreach'=>OA_LexerNames::kForeach,'if'=>OA_LexerNames::kIf,'else'=>OA_LexerNames::kElse,'switch'=>OA_LexerNames::kSwitch,'case'=>OA_LexerNames::kCase,'default'=>OA_LexerNames::kDefault,'true'=>OA_LexerNames::kTrue,'false'=>OA_LexerNames::kFalse,'null'=>OA_LexerNames::kNull,'private'=>OA_LexerNames::kPrivate,'protected'=>OA_LexerNames::kProtected,'public'=>OA_LexerNames::kPublic,'static'=>OA_LexerNames::kStatic,'function'=>OA_LexerNames::kFunction,'class'=>OA_LexerNames::kClass,'abstract'=>OA_LexerNames::kAbstract,'interface'=>OA_LexerNames::kInterface,'as'=>OA_LexerNames::kAs,'const'=>OA_LexerNames::kConst,'return'=>OA_LexerNames::kReturn,'array'=>OA_LexerNames::kArray,'list'=>OA_LexerNames::kList,'new'=>OA_LexerNames::kNew,'extends'=>OA_LexerNames::kExtends,'implements'=>OA_LexerNames::kImplements,'echo'=>OA_LexerNames::kEcho,'instanceof'=>OA_LexerNames::kInstanceOf,'__FILE__'=>OA_LexerNames::kFile,'DIRECTORY_SEPARATOR'=>OA_LexerNames::kDirectorySeparator,'PATH_SEPARATOR'=>OA_LexerNames::kPathSeparator,'global'=>OA_LexerNames::kGlobal,'parent'=>OA_LexerNames::kParent,);
public static $nonIdentifierMap=array("\n"=>OA_LexerNames::kNewLine,'{'=>OA_LexerNames::kOpenBrace,'}'=>OA_LexerNames::kCloseBrace,'('=>OA_LexerNames::kOpenParen,')'=>OA_LexerNames::kCloseParen,'['=>OA_LexerNames::kOpenSquare,']'=>OA_LexerNames::kCloseSquare,';'=>OA_LexerNames::kSemiColon,'::'=>OA_LexerNames::kColonColon,','=>OA_LexerNames::kComma,'->'=>OA_LexerNames::kCall,'@'=>OA_LexerNames::kAt,'|'=>OA_LexerNames::kBitOR,'||'=>OA_LexerNames::kLogicOR,'|='=>OA_LexerNames::kOrEqual,'&'=>OA_LexerNames::kBitAND,'&&'=>OA_LexerNames::kLogicAND,'&='=>OA_LexerNames::kAndEqual,'^'=>OA_LexerNames::kXOR,'!'=>OA_LexerNames::kNOT,'/'=>OA_LexerNames::kSlash,'-'=>OA_LexerNames::kMinus,'--'=>OA_LexerNames::kMinusMinus,'*'=>OA_LexerNames::kStar,'*='=>OA_LexerNames::kStarEqual,'+'=>OA_LexerNames::kPlus,'++'=>OA_LexerNames::kPlusPlus,'+='=>OA_LexerNames::kPlusEqual,'-='=>OA_LexerNames::kMinusEqual,'.'=>OA_LexerNames::kDot,'.='=>OA_LexerNames::kDotEqual,'%'=>OA_LexerNames::kPercent,'='=>OA_LexerNames::kEqual,'=='=>OA_LexerNames::kEqualEqual,'!='=>OA_LexerNames::kNotEqual,'==='=>OA_LexerNames::kEqualEqualEqual,'!=='=>OA_LexerNames::kNotEqualEqual,'>'=>OA_LexerNames::kGreater,'=>'=>OA_LexerNames::kEqualGreater,'>='=>OA_LexerNames::kGreaterEqual,'<'=>OA_LexerNames::kLess,'=<'=>OA_LexerNames::kEqualLess,'<='=>OA_LexerNames::kLessEqual,'?'=>OA_LexerNames::kQuestion,':'=>OA_LexerNames::kColon,);
public static function lengthSort($a,$b){$aLength=strlen($a);
$bLength=strlen($b);
$result=0;
if($aLength!==$bLength){$result=($aLength>$bLength)?-1:1;
}return $result;
}}abstract class OA_ParsedElement{private $name;
private $parentTree;
protected function __construct($name){$this->name=$name;
$this->parentTree=null;
}public function getName(){return $this->name;
}public function setParent($parent){assert($parent instanceof OA_ParseTree);
assert(null===$this->parentTree);
$this->parentTree=$parent;
}public function removeFromTree(){assert(null!==$this->parentTree);
$this->parentTree->removeChild($this);
$this->parentTree=null;
}public abstract function visit($visitor);
}class OA_LexerToken extends OA_ParsedElement{private $text;
private $file;
private $line;
public function __construct($name,$text,$file,$line){parent::__construct($name);
$this->text=$text;
$this->file=$file;
$this->line=$line;
}public function visit($visitor){$visitor->visitLeaf($this);
}public function getText(){return $this->text;
}public function getFile(){return $this->file;
}public function getLine(){return $this->line;
}}class OA_Lexer{private $preprocessor;
private $sortedKeywordArray;
private $buffer;
private $fileName;
private $line;
private $error;
public function __construct($preprocessor){$this->preprocessor=$preprocessor;
$nonIdentifiers=array_keys(OA_LexerMaps::$nonIdentifierMap);
//EXPORT OA_LexerMaps::lengthSort;
usort($nonIdentifiers,'OA_LexerMaps::lengthSort');
$this->sortedNonIdentifierArray=$nonIdentifiers;
$this->_refreshBuffer();
}public function getNextToken(){$token=null;
if(''===$this->buffer){$this->_refreshBuffer();
}if(null!==$this->buffer){$prefix=$this->buffer[0];
if('/'===$prefix){if(0===strpos($this->buffer,'//$')){$bufferLength=strlen($this->buffer);
$token=$this->_advanceBufferAndCreate(OA_LexerNames::kSpecialComment,$bufferLength-1);
}else if(0===strpos($this->buffer,'//EXPORT')){$token=$this->_advanceBufferAndCreate(OA_LexerNames::kExportComment,strlen('//EXPORT'));
}else if(0===strpos($this->buffer,'//')){$bufferLength=strlen($this->buffer);
$token=$this->_advanceBufferAndCreate(OA_LexerNames::kSingleComment,$bufferLength-1);
}else if(0===strpos($this->buffer,'/*')){$commentClose='*/';
while((null===$this->error)&&(false===strpos($this->buffer,$commentClose))){list($line,$this->fileName,$this->line,$this->error)=$this->preprocessor->getLine();
if(null!==$line){$this->buffer.=$line;
}else{$preError=$this->preprocessor->getError();
if(null!==$preError){$this->error=$preError;
}else{$this->error='End of input while searching for comment end';
}}}$end=strpos($this->buffer,$commentClose);
if(false!==$end){$token=$this->_advanceBufferAndCreate(OA_LexerNames::kMultiComment,$end+strlen($commentClose));
}}else{$token=$this->_advanceBufferAndCreate(OA_LexerNames::kSlash,1);
}}else{$tokenName=null;
$parsedIdentifier=null;
$textLength=0;
switch($prefix){case'$':list($tokenName,$textLength)=$this->_parseIdentifier(OA_LexerNames::kVariable,1);
break;
case'\'':list($tokenName,$textLength)=$this->_matchQuotedString(OA_LexerNames::kSingleQuoteString,$prefix);
break;
case'"':list($tokenName,$textLength)=$this->_matchQuotedString(OA_LexerNames::kDoubleQuoteString,$prefix);
break;
case' ':case"\t":list($tokenName,$textLength)=$this->_matchWhitespace(OA_LexerNames::kWhiteSpace);
break;
default:if(('_'===$prefix)||ctype_alpha($prefix)){list($parsedIdentifier,$textLength)=$this->_parseIdentifier(OA_LexerNames::kIdentifier,0);
}else if(ctype_digit($prefix)){list($tokenName,$textLength)=$this->_matchNumber();
}}if(null!==$parsedIdentifier){$tokenName=$this->_reduceParsedIdentifier($parsedIdentifier,$textLength);
assert(null!==$tokenName);
}else if(null===$tokenName){list($tokenName,$textLength)=$this->_getLongestNonIdentifierToken();
}if(null!==$tokenName){assert($textLength>0);
$token=$this->_advanceBufferAndCreate($tokenName,$textLength);
}else{$this->error='No token found starting line: '.$this->buffer;
}}}return $token;
}public function getError(){return $this->error;
}private function _refreshBuffer(){list($this->buffer,$this->fileName,$this->line,$this->error)=$this->preprocessor->getLine();
}private function _advanceBufferAndCreate($tokenName,$count){$extracted=null;
$length=strlen($this->buffer);
if($count===$length){$extracted=$this->buffer;
$this->buffer='';
}else{assert($count<$length);
$extracted=substr($this->buffer,0,$count);
$this->buffer=substr($this->buffer,$count);
}return new OA_LexerToken($tokenName,$extracted,$this->fileName,$this->line);
}private function _reduceParsedIdentifier($longestToken,$longestLength){$reducedToken=$longestToken;
$text=substr($this->buffer,0,$longestLength);
if(isset(OA_LexerMaps::$identifierMap[$text])){$reducedToken=OA_LexerMaps::$identifierMap[$text];
}return $reducedToken;
}private function _getLongestNonIdentifierToken(){$token=null;
$length=0;
foreach($this->sortedNonIdentifierArray as $keyword){if(0===strpos($this->buffer,$keyword)){$length=strlen($keyword);
$token=OA_LexerMaps::$nonIdentifierMap[$keyword];
break;
}}return array($token,$length);
}private function _matchQuotedString($tokenName,$quote){$i=1;
$endMatch=0;
$limit=strlen($this->buffer);
$isEscape=false;
while(($i<$limit)&&(0===$endMatch)){$char=$this->buffer[$i];
if('\\'===$char){$isEscape=!$isEscape;
}else{if(!$isEscape&&($quote===$char)){$endMatch=$i;
}$isEscape=false;
}$i+=1;
}$token=null;
$length=null;
if(0!==$endMatch){$token=$tokenName;
$length=$endMatch+1;
}else{$this->error='Reached end of line while reading string constant';
}return array($token,$length);
}private function _parseIdentifier($tokenName,$startIndex){$i=$startIndex;
$firstMiss=null;
$limit=strlen($this->buffer);
while(($i<$limit)&&(null===$firstMiss)){$char=$this->buffer[$i];
if(('_'===$char)||ctype_alnum($char)){$i+=1;
}else{$firstMiss=$i;
}}$token=null;
$length=null;
if($firstMiss!==$startIndex){$token=$tokenName;
$length=$firstMiss;
}else{$this->error='Expected identifier but found empty';
}return array($token,$length);
}private function _matchWhitespace($tokenName){$i=1;
$firstMiss=null;
$limit=strlen($this->buffer);
while(($i<$limit)&&(null===$firstMiss)){$char=$this->buffer[$i];
if((' '===$char)||("\t"===$char)){$i+=1;
}else{$firstMiss=$i;
}}if(null===$firstMiss){$firstMiss=$limit;
}$token=$tokenName;
$length=$firstMiss;
return array($token,$length);
}private function _matchNumber(){$i=1;
$firstMiss=null;
$isFloat=false;
$didError=false;
$limit=strlen($this->buffer);
while(($i<$limit)&&(null===$firstMiss)&&!$didError){$char=$this->buffer[$i];
if(ctype_digit($char)){$i+=1;
}else if('.'===$char){if(!$isFloat){$isFloat=true;
}else{$didError=true;
}$i+=1;
}else{$firstMiss=$i;
}}$token=null;
$length=null;
if(!$didError){$token=($isFloat?OA_LexerNames::kFloatConst:OA_LexerNames::kIntConst);
$length=$firstMiss;
}else{$this->error='Number had multiple decimal points';
}return array($token,$length);
}}class OA_LexerFilter{private $lexer;
private $nextToken;
private $isDone;
public function __construct($lexer){assert($lexer instanceof OA_Lexer);
$this->lexer=$lexer;
$this->nextToken=null;
$this->isDone=false;
}public function peakNextToken(){while(!$this->isDone&&(null===$this->nextToken)){$token=$this->lexer->getNextToken();
if(null!==$token){$name=$token->getName();
switch($name){case OA_LexerNames::kWhiteSpace:case OA_LexerNames::kNewLine:case OA_LexerNames::kSingleComment:case OA_LexerNames::kMultiComment:break;
case OA_LexerNames::kFile:case OA_LexerNames::kDirectorySeparator:case OA_LexerNames::kPathSeparator:$this->nextToken=new OA_LexerToken(OA_LexerNames::kSingleQuoteString,$token->getText(),$token->getFile(),$token->getLine());
break;
default:$this->nextToken=$token;
}}else{$this->isDone=true;
$this->nextToken=new OA_LexerToken('$end','','','');
}}return $this->nextToken;
}public function acceptToken(){assert(null!==$this->nextToken);
if(!$this->isDone){$this->nextToken=null;
}}}class OA_Parser{private $rules;
private $states;
public function __construct(){$this->rules=array();
$this->states=array();
}public function parse($rawLexer){assert($rawLexer instanceof OA_Lexer);
$lexer=new OA_LexerFilter($rawLexer);
$symbolStack=array();
$stateStack=array('0');
$acceptedTree=null;
while(null===$acceptedTree){$token=$lexer->peakNextToken();
assert($token instanceof OA_LexerToken);
$currentStateNumber=$stateStack[count($stateStack)-1];
$symbol=$token->getName();
$currentStateObject=$this->states[$currentStateNumber];
$shiftState=$currentStateObject->getShiftForSymbol($symbol);
if(null!==$shiftState){assert(is_string($shiftState));
$lexer->acceptToken();
array_push($symbolStack,$token);
array_push($stateStack,$shiftState);
}else{$reductionNumber=$currentStateObject->getReductionForSymbol($symbol);
if(null!==$reductionNumber){$shouldAccept=false;
if('accept'===$reductionNumber){$shouldAccept=true;
$reductionNumber=0;
}assert(isset($this->rules[$reductionNumber]));
$reductionRule=$this->rules[$reductionNumber];
$consumedCount=$reductionRule->consumedCount();
assert($consumedCount<=count($symbolStack));
assert($consumedCount<count($stateStack));
$argArray=array();
for($i=0;
$i<$consumedCount;
++$i){$arg=array_pop($symbolStack);
array_pop($stateStack);
array_unshift($argArray,$arg);
}$tree=$reductionRule->applyRule($argArray);
assert($tree instanceof OA_ParseTree);
if($shouldAccept){$acceptedTree=$tree;
}else{$newStateObject=$this->states[$stateStack[count($stateStack)-1]];
$gotoState=$newStateObject->getGotoForSymbol($tree->getName());
assert(null!==$gotoState);
array_push($symbolStack,$tree);
array_push($stateStack,$gotoState);
}}else{error_log("UNEXPECTED $symbol (\"{$token->getText()}\") {$token->getFile()}:{$token->getLine()}");
assert(false);
}}}assert(0===count($symbolStack));
assert(1===count($stateStack));
return $acceptedTree;
}public function addRule($number,$ruleObject){assert($ruleObject instanceof OA_ParserRule);
$this->rules[$number]=$ruleObject;
}public function addState($number,$stateObject){assert($stateObject instanceof OA_ParserState);
$this->states[$number]=$stateObject;
}}class OA_ParseTree extends OA_ParsedElement{private $children;
public function __construct($name){parent::__construct($name);
$this->children=array();
}public function visit($visitor){$shouldVisit=$visitor->preVisitTree($this);
if($shouldVisit){foreach($this->children as $child){$child->visit($visitor);
}}$visitor->postVisitTree($this);
}public function addChild($child){assert($child instanceof OA_ParsedElement);
$this->children[]=$child;
$child->setParent($this);
}public function removeChild($child){$oldChildren=$this->children;
$this->children=array();
$found=false;
foreach($oldChildren as $oldChild){if($oldChild===$child){assert(!$found);
$found=true;
}else{$this->children[]=$oldChild;
}}assert($found);
}}class OA_ParserRule{private $lhs;
private $rhs;
public function __construct($lhs,$rhs){assert(is_array($rhs));
$this->lhs=$lhs;
$this->rhs=$rhs;
}public function consumedCount(){return count($this->rhs);
}public function applyRule($tokenArray){$size=count($tokenArray);
assert($size===count($this->rhs));
$tree=new OA_ParseTree($this->lhs);
for($i=0;
$i<$size;
++$i){$tokenObject=$tokenArray[$i];
assert($tokenObject->getName()===$this->rhs[$i]);
$tree->addChild($tokenObject);
}return $tree;
}}class OA_ParserState{private $shiftTransitions;
private $gotoTransitions;
private $reductions;
public function __construct(){$this->shiftTransitions=array();
$this->gotoTransitions=array();
$this->reductions=array();
}public function addShift($symbol,$state){$this->shiftTransitions[$symbol]=$state;
}public function addGoto($symbol,$state){$this->gotoTransitions[$symbol]=$state;
}public function addReduction($symbol,$rule){$this->reductions[$symbol]=$rule;
}public function getShiftForSymbol($symbol){$shiftState=null;
if(isset($this->shiftTransitions[$symbol])){$shiftState=$this->shiftTransitions[$symbol];
}return $shiftState;
}public function getGotoForSymbol($symbol){$gotoState=null;
if(isset($this->gotoTransitions[$symbol])){$gotoState=$this->gotoTransitions[$symbol];
}return $gotoState;
}public function getReductionForSymbol($symbol){$reductionRule=null;
if(isset($this->reductions[$symbol])){$reductionRule=$this->reductions[$symbol];
}else{if(isset($this->reductions['$default'])){$reductionRule=$this->reductions['$default'];
}}return $reductionRule;
}}class OA_ParserBuilder{const kTransitionShift='shift';
const kTransitionGoto='goto';
public static function buildFromXmlFile($path){$parserObject=new OA_Parser();
$data=simplexml_load_file($path);
$grammarNode=$data->grammar;
$rulesNode=$grammarNode->rules;
foreach($rulesNode->children()as $node){$lhs=(string)$node->lhs;
$rhs=array();
foreach($node->rhs->symbol as $symbolNode){$rhs[]=(string)$symbolNode;
}$rule=new OA_ParserRule($lhs,$rhs);
$number=(string)$node->attributes()->number;
$parserObject->addRule($number,$rule);
}foreach($data->automaton->state as $stateNode){$stateObject=new OA_ParserState();
foreach($stateNode->actions->transitions->transition as $transitionNode){$attributes=$transitionNode->attributes();
$symbol=(string)$attributes->symbol;
$state=(string)$attributes->state;
switch((string)$attributes->type){case OA_ParserBuilder::kTransitionShift:$stateObject->addShift($symbol,$state);
break;
case OA_ParserBuilder::kTransitionGoto:$stateObject->addGoto($symbol,$state);
break;
default:assert(false);
}}foreach($stateNode->actions->reductions->reduction as $reductionNode){$attributes=$reductionNode->attributes();
$symbol=(string)$attributes->symbol;
$rule=(string)$attributes->rule;
$stateObject->addReduction($symbol,$rule);
}$number=(string)$stateNode->attributes()->number;
$parserObject->addState($number,$stateObject);
}return $parserObject;
}}interface OA_ITreeWalker{public function preVisitTree($tree);
public function postVisitTree($tree);
public function visitLeaf($leaf);
}class OA_OutputVisitor implements OA_ITreeWalker{private $outputStream;
public function __construct($outputStream){$this->outputStream=$outputStream;
}public function preVisitTree($tree){return true;
}public function postVisitTree($tree){}public function visitLeaf($leaf){$this->outputStream->writeToken($leaf);
}}class OA_TokenOutputStream{const kBufferSize=65536;
private static $spaceDelimitedTokens=array(OA_LexerNames::kIf,OA_LexerNames::kElse,OA_LexerNames::kCase,OA_LexerNames::kTrue,OA_LexerNames::kFalse,OA_LexerNames::kNull,OA_LexerNames::kPrivate,OA_LexerNames::kProtected,OA_LexerNames::kPublic,OA_LexerNames::kStatic,OA_LexerNames::kFunction,OA_LexerNames::kClass,OA_LexerNames::kAbstract,OA_LexerNames::kInterface,OA_LexerNames::kAs,OA_LexerNames::kConst,OA_LexerNames::kReturn,OA_LexerNames::kArray,OA_LexerNames::kNew,OA_LexerNames::kExtends,OA_LexerNames::kImplements,OA_LexerNames::kEcho,OA_LexerNames::kInstanceOf,OA_LexerNames::kIdentifier,OA_LexerNames::kIntConst,OA_LexerNames::kFloatConst,OA_LexerNames::kVariable,OA_LexerNames::kExportComment,);
private $stream;
private $buffer;
private $needsSpace;
public function __construct($stream){$this->stream=$stream;
$this->buffer='';
$this->needsSpace=false;
}public function writeToken($leaf){if(strlen($this->buffer)>OA_TokenOutputStream::kBufferSize){$this->_flush();
}$leafName=$leaf->getName();
$leafText=$leaf->getText();
if(OA_LexerNames::kSpecialComment===$leafName){$this->buffer.="\n$leafText\n";
$this->needsSpace=false;
}else{$needsSpace=in_array($leafName,OA_TokenOutputStream::$spaceDelimitedTokens);
if($this->needsSpace&&$needsSpace){$this->buffer.=' ';
}$this->buffer.=$leafText;
if(OA_LexerNames::kSemiColon===$leafName){$this->buffer.="\n";
$this->needsSpace=false;
}else{$this->needsSpace=$needsSpace;
}}}public function finish(){$this->_flush();
fwrite($this->stream,"\n");
$this->stream=null;
$this->buffer=null;
}private function _flush(){fwrite($this->stream,$this->buffer);
$this->buffer='';
}}class OA_Symbol_FunctionDeclaration{private $isAlive;
private $functionTreeTop;
private $nameToken;
private $functionCallObjects;
public function __construct($functionTreeTop,$nameToken,$functionCallObjects){assert(null!==$functionTreeTop);
assert(null!==$nameToken);
assert(null!==$functionCallObjects);
$this->isAlive=false;
$this->functionTreeTop=$functionTreeTop;
$this->nameToken=$nameToken;
$this->functionCallObjects=$functionCallObjects;
}public function getDescription($indentation,$namePrefix){$functionName=$this->nameToken->getText();
$fileName=$this->nameToken->getFile();
$lineNumber=$this->nameToken->getLine();
$liveness=($this->isAlive?'alive':'DEAD');
$string=$indentation."FUNCTION: $namePrefix$functionName ($liveness)\n\t(declared $fileName:$lineNumber)\n";
foreach($this->functionCallObjects as $functionCallObject){$string.="\t\t".$functionCallObject->getDescription();
}return $string;
}public function getName(){return $this->nameToken->getText();
}public function setAliveAndGetCalls(){$calls=array();
if(!$this->isAlive){$this->isAlive=true;
$calls=$this->functionCallObjects;
}return $calls;
}public function cleanIfDead(){if(!$this->isAlive){$this->functionTreeTop->removeFromTree();
}}}class OA_FunctionDeclarationWalker implements OA_ITreeWalker{const kIdentifier='IDENTIFIER';
private $callingContext;
private $functionTreeTop;
private $functionNameToken;
private $functionCallObjects;
public function __construct($callingContext,$functionTreeTop){$this->callingContext=$callingContext;
$this->functionTreeTop=$functionTreeTop;
$this->functionNameToken=null;
$this->functionCallObjects=array();
}public function preVisitTree($tree){$shouldVisitChildren=true;
$callObject=OA_CodeBlockHelpers::findCallObject($this->callingContext,$tree,$tree->getName());
if(null!==$callObject){$this->functionCallObjects[]=$callObject;
}return $shouldVisitChildren;
}public function postVisitTree($tree){}public function visitLeaf($leaf){if((null===$this->functionNameToken)&&(OA_FunctionDeclarationWalker::kIdentifier===$leaf->getName())){$this->functionNameToken=$leaf;
}}public function getFunctionDeclarationObject(){return new OA_Symbol_FunctionDeclaration($this->functionTreeTop,$this->functionNameToken,$this->functionCallObjects);
}}class OA_Symbol_ClassDeclaration{private $nameToken;
private $superclassName;
private $staticFunctions;
private $instanceFunctions;
private $exportedFunctions;
public function __construct($nameToken){$this->nameToken=$nameToken;
$this->superclassName=null;
$this->staticFunctions=array();
$this->instanceFunctions=array();
$this->exportedFunctions=array();
}public function addStaticFunction($functionObject){$this->staticFunctions[]=$functionObject;
}public function addInstanceFunction($functionObject){$this->instanceFunctions[]=$functionObject;
}public function getDescription($indentation){$className=$this->nameToken->getText();
$fileName=$this->nameToken->getFile();
$lineNumber=$this->nameToken->getLine();
$string=$indentation."CLASS: $className\n\t$fileName:$lineNumber\n";
foreach($this->staticFunctions as $functionObject){$functionString=$functionObject->getDescription("\tSTATIC ","$className::");
$string.=$functionString;
}foreach($this->instanceFunctions as $functionObject){$functionString=$functionObject->getDescription("\tINSTANCE ",'->');
$string.=$functionString;
}return $string;
}public function registerAllFunctions($registry){assert($registry instanceof OA_FunctionRegistry);
$thisClassName=$this->nameToken->getText();
if(null!==$this->superclassName){$registry->setClassRelationship($this->superclassName,$thisClassName);
}$functionPrefix=$thisClassName.'::';
foreach($this->staticFunctions as $functionObject){$functionName=$functionPrefix.$functionObject->getName();
$registry->registerNormalFunction($functionName,$functionObject);
}foreach($this->instanceFunctions as $functionObject){$functionIdentifier=$functionObject->getName();
if('__construct'===$functionIdentifier){$functionName=$functionPrefix.$functionIdentifier;
$registry->registerNormalFunction($functionName,$functionObject);
}else{$registry->registerVirtualFunction($functionIdentifier,$functionObject);
}}}public function cleanDeadFunctions(){foreach($this->staticFunctions as $functionObject){$functionObject->cleanIfDead();
}foreach($this->instanceFunctions as $functionObject){$functionObject->cleanIfDead();
}}public function addExportedFunction($functionObject){$this->exportedFunctions[]=$functionObject;
}public function getAllExportedCalls(){return $this->exportedFunctions;
}public function setSuperclassName($superclassName){$this->superclassName=$superclassName;
}}class OA_StaticFunctionDeclarationWalker implements OA_ITreeWalker{const kFunctionDecl='P_FUNCTION_DECL';
private $functionTreeTop;
private $functionObject;
public function __construct(){$this->functionTreeTop=null;
$this->functionObject=null;
}public function preVisitTree($tree){$shouldVisitChildren=(null===$this->functionTreeTop);
if(null===$this->functionTreeTop){$this->functionTreeTop=$tree;
}else{if(OA_StaticFunctionDeclarationWalker::kFunctionDecl===$tree->getName()){$callingContext=null;
$childWalker=new OA_FunctionDeclarationWalker($callingContext,$this->functionTreeTop);
$tree->visit($childWalker);
$functionObject=$childWalker->getFunctionDeclarationObject();
assert(null!==$functionObject);
$this->functionObject=$functionObject;
}}return $shouldVisitChildren;
}public function postVisitTree($tree){}public function visitLeaf($leaf){}public function getFunctionDeclarationObject(){return $this->functionObject;
}}class OA_InstanceFunctionDeclarationWalker implements OA_ITreeWalker{const kFunctionDecl='P_FUNCTION_DECL';
private $callingContext;
private $functionTreeTop;
private $functionObject;
public function __construct($callingContext){$this->callingContext=$callingContext;
$this->functionTreeTop=null;
$this->functionObject=null;
}public function preVisitTree($tree){$shouldVisitChildren=(null===$this->functionTreeTop);
if(null===$this->functionTreeTop){$this->functionTreeTop=$tree;
}else{if(OA_StaticFunctionDeclarationWalker::kFunctionDecl===$tree->getName()){$childWalker=new OA_FunctionDeclarationWalker($this->callingContext,$this->functionTreeTop);
$tree->visit($childWalker);
$functionObject=$childWalker->getFunctionDeclarationObject();
assert(null!==$functionObject);
$this->functionObject=$functionObject;
}}return $shouldVisitChildren;
}public function postVisitTree($tree){}public function visitLeaf($leaf){}public function getFunctionDeclarationObject(){return $this->functionObject;
}}interface OA_IFunctionCall{public function getDescription();
public function getTargetsFromRegistry($registry);
}class OA_Symbol_StaticCall implements OA_IFunctionCall{private $receiverClassNameToken;
private $receiverFunctionNameToken;
public function __construct($receiverClassNameToken,$receiverFunctionNameToken){$this->receiverClassNameToken=$receiverClassNameToken;
$this->receiverFunctionNameToken=$receiverFunctionNameToken;
}public function getDescription(){$className=$this->receiverClassNameToken->getText();
$functionName=$this->receiverFunctionNameToken->getText();
return"STATIC $className::$functionName()\n";
}public function getTargetsFromRegistry($registry){$className=$this->receiverClassNameToken->getText();
$functionName=$this->receiverFunctionNameToken->getText();
$identifier=OA_FunctionRegistry::createNameForStaticFunction($className,$functionName);
$target=$registry->resolveStaticReceiverForName($identifier);
return(null!==$target)?array($target):array();
}}class OA_CallingContext{private $classNameToken;
public function __construct($classNameToken){$this->classNameToken=$classNameToken;
}public function getClassNameToken(){return $this->classNameToken;
}}class OA_AbstractFunctionDeclarationWalker implements OA_ITreeWalker{const kIdentifier='IDENTIFIER';
private $functionNameToken;
public function __construct(){$this->functionNameToken=null;
}public function preVisitTree($tree){return(null===$this->functionNameToken);
}public function postVisitTree($tree){}public function visitLeaf($leaf){if((null===$this->functionNameToken)&&(OA_FunctionDeclarationWalker::kIdentifier===$leaf->getName())){$this->functionNameToken=$leaf;
}}public function getFunctionDeclarationObject(){return new OA_Symbol_VirtualCall($this->functionNameToken);
}}class OA_ClassDeclarationWalker implements OA_ITreeWalker{const kIdentifier='IDENTIFIER';
const kClassLines='P_CLASS_LINES';
const kClassLine='P_CLASS_LINE';
const kInterfaceLines='P_INTERFACE_LINES';
const kStaticFunctionDecl='P_STATIC_FUNCTION_DECL';
const kInstanceFunctionDecl='P_INST_FUNCTION_DECL';
const kInterfaceLine='P_INTERFACE_LINE';
const kAbstractFunctionDecl='P_ABSTRACT_FUNCTION_DECL';
const kExtension='P_EXTENSION';
private static $whitelist=array(OA_ClassDeclarationWalker::kClassLines,OA_ClassDeclarationWalker::kClassLine,OA_ClassDeclarationWalker::kInterfaceLines,);
private $className;
private $classObject;
private $isWalkingClass;
private $isWalkingExtension;
private $callingContext;
public function __construct(){$this->className=null;
$this->classObject=null;
$this->isWalkingClass=false;
$this->isWalkingExtension=false;
$this->callingContext=null;
}public function preVisitTree($tree){$shouldVisitChildren=true;
if($this->isWalkingClass){$name=$tree->getName();
$shouldVisitChildren=false;
if(in_array($name,OA_ClassDeclarationWalker::$whitelist)){$shouldVisitChildren=true;
}else if(OA_ClassDeclarationWalker::kStaticFunctionDecl===$name){$childWalker=new OA_StaticFunctionDeclarationWalker();
$tree->visit($childWalker);
$functionObject=$childWalker->getFunctionDeclarationObject();
assert(null!==$functionObject);
$this->classObject->addStaticFunction($functionObject);
}else if(OA_ClassDeclarationWalker::kInstanceFunctionDecl===$name){$childWalker=new OA_InstanceFunctionDeclarationWalker($this->callingContext);
$tree->visit($childWalker);
$functionObject=$childWalker->getFunctionDeclarationObject();
assert(null!==$functionObject);
$this->classObject->addInstanceFunction($functionObject);
}else if((OA_ClassDeclarationWalker::kInterfaceLine===$name)||(OA_ClassDeclarationWalker::kAbstractFunctionDecl===$name)){$childWalker=new OA_AbstractFunctionDeclarationWalker();
$tree->visit($childWalker);
$functionObject=$childWalker->getFunctionDeclarationObject();
assert(null!==$functionObject);
$this->classObject->addExportedFunction($functionObject);
}else if(OA_ClassDeclarationWalker::kExtension===$name){$this->isWalkingExtension=true;
$shouldVisitChildren=true;
}}$this->isWalkingClass=true;
return $shouldVisitChildren;
}public function postVisitTree($tree){if($this->isWalkingExtension&&(OA_ClassDeclarationWalker::kExtension===$tree->getName())){$this->isWalkingExtension=false;
}}public function visitLeaf($leaf){if(OA_ClassDeclarationWalker::kIdentifier===$leaf->getName()){if(null===$this->classObject){$this->className=$leaf->getText();
$this->classObject=new OA_Symbol_ClassDeclaration($leaf);
}else if($this->isWalkingExtension){$this->classObject->setSuperclassName($leaf->getText());
$this->callingContext=new OA_CallingContext($leaf);
}}}public function getClassDeclarationObject(){return $this->classObject;
}}class OA_Symbol_NewCall implements OA_IFunctionCall{private $receiverClassNameToken;
public function __construct($receiverClassNameToken){$this->receiverClassNameToken=$receiverClassNameToken;
}public function getDescription(){$className=$this->receiverClassNameToken->getText();
return"new $className()\n";
}public function getTargetsFromRegistry($registry){$target=null;
$className=$this->receiverClassNameToken->getText();
while((null===$target)&&(null!==$className)){$identifier=OA_FunctionRegistry::createNameForConstructor($className);
$target=$registry->resolveStaticReceiverForName($identifier);
if(null===$target){$className=$registry->getSuperclassName($className);
}}return(null!==$target)?array($target):array();
}}class OA_CallNewWalker implements OA_ITreeWalker{const kIdentifier='IDENTIFIER';
const kCallNew='P_NEW';
private $receiverClassNameToken;
public function __construct(){$this->receiverClassNameToken=null;
}public function preVisitTree($tree){return($tree->getName()===OA_CallNewWalker::kCallNew);
}public function postVisitTree($tree){}public function visitLeaf($leaf){if(OA_CallNewWalker::kIdentifier===$leaf->getName()){assert(null===$this->receiverClassNameToken);
$this->receiverClassNameToken=$leaf;
}}public function getFunctionCallObject(){return new OA_Symbol_NewCall($this->receiverClassNameToken);
}}class OA_Symbol_GlobalCall implements OA_IFunctionCall{private $functionNameToken;
public function __construct($functionNameToken){$this->functionNameToken=$functionNameToken;
}public function getDescription(){$functionName=$this->functionNameToken->getText();
return"GLOBAL $functionName()\n";
}public function getTargetsFromRegistry($registry){$target=$registry->resolveStaticReceiverForName($this->functionNameToken->getText());
return(null!==$target)?array($target):array();
}}class OA_CallGlobalWalker implements OA_ITreeWalker{const kIdentifier='IDENTIFIER';
private $functionNameToken;
public function __construct(){$this->functionNameToken=null;
}public function preVisitTree($tree){return(null===$this->functionNameToken);
}public function postVisitTree($tree){}public function visitLeaf($leaf){$name=$leaf->getName();
if(OA_CallGlobalWalker::kIdentifier===$name){assert(null===$this->functionNameToken);
$this->functionNameToken=$leaf;
}}public function getFunctionCallObject(){assert(null!==$this->functionNameToken);
return new OA_Symbol_GlobalCall($this->functionNameToken);
}}class OA_CallStaticWalker implements OA_ITreeWalker{const kIdentifier='IDENTIFIER';
const kStaticCall='P_STATIC_CALL';
private $receiverClassNameToken;
private $receiverFunctionNameToken;
public function __construct(){$this->receiverClassNameToken=null;
$this->receiverFunctionNameToken=null;
}public function preVisitTree($tree){return($tree->getName()===OA_CallStaticWalker::kStaticCall);
}public function postVisitTree($tree){}public function visitLeaf($leaf){if(OA_CallStaticWalker::kIdentifier===$leaf->getName()){if(null===$this->receiverClassNameToken){$this->receiverClassNameToken=$leaf;
}else if(null===$this->receiverFunctionNameToken){$this->receiverFunctionNameToken=$leaf;
}else{assert(false);
}}}public function getFunctionCallObject(){return new OA_Symbol_StaticCall($this->receiverClassNameToken,$this->receiverFunctionNameToken);
}}class OA_Symbol_VirtualCall implements OA_IFunctionCall{private $receiverFunctionNameToken;
public function __construct($receiverFunctionNameToken){$this->receiverFunctionNameToken=$receiverFunctionNameToken;
}public function getDescription(){$functionName=$this->receiverFunctionNameToken->getText();
return"VIRTUAL ->$functionName()\n";
}public function getTargetsFromRegistry($registry){return $registry->resolveVirtualReceiversForName($this->receiverFunctionNameToken->getText());
}}class OA_CallVirtualWalker implements OA_ITreeWalker{const kIdentifier='IDENTIFIER';
const kVirtualCall='P_VIRTUAL_CALL';
private $receiverFunctionNameToken;
public function __construct(){$this->receiverFunctionNameToken=null;
}public function preVisitTree($tree){return($tree->getName()===OA_CallVirtualWalker::kVirtualCall);
}public function postVisitTree($tree){}public function visitLeaf($leaf){if(OA_CallVirtualWalker::kIdentifier===$leaf->getName()){assert(null===$this->receiverFunctionNameToken);
$this->receiverFunctionNameToken=$leaf;
}}public function getFunctionCallObject(){return new OA_Symbol_VirtualCall($this->receiverFunctionNameToken);
}}class OA_CallParentWalker implements OA_ITreeWalker{const kIdentifier='IDENTIFIER';
const kParentCall='P_PARENT_CALL';
private $callingContext;
private $receiverFunctionNameToken;
public function __construct($callingContext){$this->callingContext=$callingContext;
$this->receiverFunctionNameToken=null;
}public function preVisitTree($tree){return($tree->getName()===OA_CallParentWalker::kParentCall);
}public function postVisitTree($tree){}public function visitLeaf($leaf){if(OA_CallParentWalker::kIdentifier===$leaf->getName()){assert(null===$this->receiverFunctionNameToken);
$this->receiverFunctionNameToken=$leaf;
}}public function getFunctionCallObject(){$object=null;
if('__construct'===$this->receiverFunctionNameToken->getText()){$object=new OA_Symbol_NewCall($this->callingContext->getClassNameToken());
}else{$object=new OA_Symbol_VirtualCall($this->receiverFunctionNameToken);
}return $object;
}}class OA_ExportWalker implements OA_ITreeWalker{const kIdentifier='IDENTIFIER';
private $firstIdentifierToken;
private $secondIdentifierToken;
public function __construct(){$this->firstIdentifierToken=null;
$this->secondIdentifierToken=null;
}public function preVisitTree($tree){return true;
}public function postVisitTree($tree){}public function visitLeaf($leaf){if(OA_CallStaticWalker::kIdentifier===$leaf->getName()){if(null===$this->firstIdentifierToken){$this->firstIdentifierToken=$leaf;
}else if(null===$this->secondIdentifierToken){$this->secondIdentifierToken=$leaf;
}else{assert(false);
}}}public function getFunctionCallObject(){$object=null;
if(null!==$this->secondIdentifierToken){$object=new OA_Symbol_StaticCall($this->firstIdentifierToken,$this->secondIdentifierToken);
}else{$object=new OA_Symbol_GlobalCall($this->firstIdentifierToken);
}return $object;
}}class OA_CodeBlockHelpers{const kCallNew='P_NEW';
const kCallGlobal='P_GLOBAL_CALL';
const kCallStatic='P_STATIC_CALL';
const kCallVirtual='P_VIRTUAL_CALL';
const kCallParent='P_PARENT_CALL';
const kExport='P_EXPORT_COMMENT';
public static function findCallObject($callingContext,$tree,$treeName){$callObject=null;
switch($treeName){case OA_CodeBlockHelpers::kCallNew:$childWalker=new OA_CallNewWalker();
$tree->visit($childWalker);
$callObject=$childWalker->getFunctionCallObject();
break;
case OA_CodeBlockHelpers::kCallGlobal:$childWalker=new OA_CallGlobalWalker();
$tree->visit($childWalker);
$callObject=$childWalker->getFunctionCallObject();
break;
case OA_CodeBlockHelpers::kCallStatic:$childWalker=new OA_CallStaticWalker();
$tree->visit($childWalker);
$callObject=$childWalker->getFunctionCallObject();
break;
case OA_CodeBlockHelpers::kCallVirtual:$childWalker=new OA_CallVirtualWalker();
$tree->visit($childWalker);
$callObject=$childWalker->getFunctionCallObject();
break;
case OA_CodeBlockHelpers::kCallParent:assert($callingContext instanceof OA_CallingContext);
$childWalker=new OA_CallParentWalker($callingContext);
$tree->visit($childWalker);
$callObject=$childWalker->getFunctionCallObject();
break;
case OA_CodeBlockHelpers::kExport:$childWalker=new OA_ExportWalker();
$tree->visit($childWalker);
$callObject=$childWalker->getFunctionCallObject();
break;
default:}return $callObject;
}}class OA_FunctionRegistry{public static function createNameForConstructor($className){return"$className::__construct";
}public static function createNameForStaticFunction($className,$functionName){return"$className::$functionName";
}private $normalFunctionMap;
private $virtualFunctionArrayMap;
private $classRelationshipMap;
public function __construct(){$this->normalFunctionMap=array();
$this->virtualFunctionArrayMap=array();
$this->classRelationshipMap=array();
}public function registerNormalFunction($functionName,$functionObject){assert(!isset($this->normalFunctionMap[$functionName]));
$this->normalFunctionMap[$functionName]=$functionObject;
}public function registerVirtualFunction($functionIdentifier,$functionObject){$array=isset($this->virtualFunctionArrayMap[$functionIdentifier])?$this->virtualFunctionArrayMap[$functionIdentifier]:array();
$array[]=$functionObject;
$this->virtualFunctionArrayMap[$functionIdentifier]=$array;
}public function resolveStaticReceiverForName($functionName){return isset($this->normalFunctionMap[$functionName])?$this->normalFunctionMap[$functionName]:null;
}public function resolveVirtualReceiversForName($functionName){return isset($this->virtualFunctionArrayMap[$functionName])?$this->virtualFunctionArrayMap[$functionName]:array();
}public function setClassRelationship($parent,$child){$this->classRelationshipMap[$child]=$parent;
}public function getSuperclassName($childClassName){$name=null;
if(isset($this->classRelationshipMap[$childClassName])){$name=$this->classRelationshipMap[$childClassName];
}return $name;
}}class OA_SymbolTableBuilder implements OA_ITreeWalker{const kFunctionDecl='P_FUNCTION_DECL';
const kClassDecl='P_CLASS_DECL';
const kAbstractClassDecl='P_ABSTRACT_CLASS_DECL';
const kInterfaceDecl='P_INTERFACE_DECL';
private $functionObjects;
private $classObjects;
private $functionCallObjects;
public function __construct(){$this->functionObjects=array();
$this->classObjects=array();
$this->functionCallObjects=array();
}public function preVisitTree($tree){$shouldVisitChildren=true;
$callingContext=null;
$name=$tree->getName();
switch($name){case OA_SymbolTableBuilder::kFunctionDecl:$shouldVisitChildren=false;
$childWalker=new OA_FunctionDeclarationWalker($callingContext,$tree);
$tree->visit($childWalker);
$functionObject=$childWalker->getFunctionDeclarationObject();
assert(null!==$functionObject);
$this->functionObjects[]=$functionObject;
break;
case OA_SymbolTableBuilder::kClassDecl:case OA_SymbolTableBuilder::kAbstractClassDecl:case OA_SymbolTableBuilder::kInterfaceDecl:$shouldVisitChildren=false;
$childWalker=new OA_ClassDeclarationWalker();
$tree->visit($childWalker);
$classObject=$childWalker->getClassDeclarationObject();
assert(null!==$classObject);
$this->classObjects[]=$classObject;
break;
default:$callObject=OA_CodeBlockHelpers::findCallObject($callingContext,$tree,$name);
if(null!==$callObject){$this->functionCallObjects[]=$callObject;
}}return $shouldVisitChildren;
}public function postVisitTree($tree){}public function visitLeaf($leaf){}public function performDeadCodeElimination(){$registry=new OA_FunctionRegistry();
foreach($this->functionObjects as $functionObject){$registry->registerNormalFunction($functionObject->getName(),$functionObject);
}foreach($this->classObjects as $classObject){$classObject->registerAllFunctions($registry);
}OA_SymbolTableBuilder::_markAllCalls($registry,$this->functionCallObjects);
foreach($this->classObjects as $classObject){$exportedCalls=$classObject->getAllExportedCalls();
OA_SymbolTableBuilder::_markAllCalls($registry,$exportedCalls);
}foreach($this->functionObjects as $functionObject){$functionObject->cleanIfDead();
}foreach($this->classObjects as $classObject){$classObject->cleanDeadFunctions();
}}public function writeReportToStream($stream){foreach($this->functionObjects as $functionObject){$string=$functionObject->getDescription('GLOBAL ','');
fwrite($stream,$string);
}foreach($this->classObjects as $classObject){$string=$classObject->getDescription('');
fwrite($stream,$string);
}fwrite($stream,"Top-level function calls\n");
foreach($this->functionCallObjects as $functionCallObject){$string=$functionCallObject->getDescription();
fwrite($stream,$string);
}}private static function _markAllCalls($registry,$callArray){foreach($callArray as $call){$functionObjects=$call->getTargetsFromRegistry($registry);
foreach($functionObjects as $functionObject){$calls=$functionObject->setAliveAndGetCalls();
OA_SymbolTableBuilder::_markAllCalls($registry,$calls);
}}}}class OA_PhpCompiler{private $options;
private $alreadyIncludedPathArray;
private $alreadyReferencedFileNamesArray;
public function __construct($options){assert($options instanceof OA_CompilerOptions);
$this->options=$options;
}public function compile($inputFilePath,$outputFileName){$stream=STDOUT;
$tempName=null;
if(null!==$outputFileName){$tempName=$outputFileName.'.tmp';
$stream=fopen($tempName,'w');
assert(false!==$stream);
}$preprocessor=new OA_Preprocessor($this->options->preprocessorIncludePathsArray,$this->options->preprocessorIgnoredFileNameArray);
list($startLines,$preError)=$preprocessor->start($inputFilePath);
if(null===$preError){$buffer='';
foreach($startLines as $line){$buffer.=$line;
}fwrite($stream,$buffer);
$this->_compilePhp($stream,$preprocessor);
$buffer='';
$endLines=$preprocessor->end();
foreach($endLines as $line){$buffer.=$line;
}fwrite($stream,$buffer);
}else{error_log($preError);
}if(STDOUT!==$stream){fclose($stream);
assert(null!==$tempName);
$didRename=rename($tempName,$outputFileName);
assert($didRename);
}}private function _compilePhp($stream,$preprocessor){if($this->options->preprocessOnly){$this->_drainPreprocessor($stream,$preprocessor);
}else if($this->options->stripOnly){assert(!$this->options->testLexer);
$lexer=new OA_Lexer($preprocessor);
$this->_strip($stream,$lexer);
}else if($this->options->eliminateDeadCode||(null!==$this->options->symbolTableReportPath)){assert(null!==$this->options->parserGrammarFilePath);
$parser=OA_ParserBuilder::buildFromXmlFile($this->options->parserGrammarFilePath);
assert(null!==$parser);
$lexer=new OA_Lexer($preprocessor);
$acceptedTree=$parser->parse($lexer);
if(null!==$acceptedTree){$symbolTableBuilder=new OA_SymbolTableBuilder();
$acceptedTree->visit($symbolTableBuilder);
if($this->options->eliminateDeadCode){$symbolTableBuilder->performDeadCodeElimination();
}if(null!==$this->options->symbolTableReportPath){$tempName=$this->options->symbolTableReportPath.'.tmp';
$reportStream=fopen($tempName,'w');
assert(false!==$reportStream);
$symbolTableBuilder->writeReportToStream($reportStream);
fclose($reportStream);
$didRename=rename($tempName,$this->options->symbolTableReportPath);
assert($didRename);
}$tokenStream=new OA_TokenOutputStream($stream);
$outputVisitor=new OA_OutputVisitor($tokenStream);
$acceptedTree->visit($outputVisitor);
$tokenStream->finish();
}else{error_log("Failure in parser.\n");
exit(1);
}}else{assert($this->options->testLexer);
$lexer=new OA_Lexer($preprocessor);
$this->_testLexer($stream,$lexer);
}}private function _drainPreprocessor($stream,$preprocessor){$buffer='';
list($line,$fileName,$lineNumber,$error)=$preprocessor->getLine();
while((null!==$line)&&(null===$error)){$buffer.=$line;
list($line,$fileName,$lineNumber,$error)=$preprocessor->getLine();
}fwrite($stream,$buffer);
if(null!==$error){error_log($error);
}}private function _strip($stream,$lexer){$tokenStream=new OA_TokenOutputStream($stream);
while(null!==($token=$lexer->getNextToken())){$name=$token->getName();
switch($name){case OA_LexerNames::kSingleComment:case OA_LexerNames::kMultiComment:case OA_LexerNames::kWhiteSpace:case OA_LexerNames::kNewLine:break;
default:$tokenStream->writeToken($token);
}}$tokenStream->finish();
$error=$lexer->getError();
if(null!==$error){error_log($error);
}}private function _testLexer($stream,$lexer){$buffer='';
while(null!==($token=$lexer->getNextToken())){$name=$token->getName();
if(OA_LexerNames::kNewLine===$name){$buffer.="\n";
}else{$buffer.=" $name";
}}$buffer.="\n";
fwrite($stream,$buffer);
$error=$lexer->getError();
if(null!==$error){error_log($error);
}}}class OA_CompilerOptions{public $preprocessorIncludePathsArray;
public $preprocessorIgnoredFileNameArray;
public $preprocessOnly;
public $stripOnly;
public $testLexer;
public $parserGrammarFilePath;
public $symbolTableReportPath;
public $eliminateDeadCode;
public function __construct(){$this->preprocessorIncludePathsArray=array();
$this->preprocessorIgnoredFileNameArray=array();
$this->preprocessOnly=false;
$this->stripOnly=true;
$this->testLexer=false;
$this->parserGrammarFilePath=null;
$this->symbolTableReportPath=null;
$this->eliminateDeadCode=false;
}}function parseCommandLine($options,$argc,$argv){$inputFilePath=null;
$outputFileName=null;
$parsingInclude=false;
$parsingIgnore=false;
$parsingOutput=false;
for($i=1;
$i<$argc;
++$i){$arg=$argv[$i];
if($parsingInclude){$options->preprocessorIncludePathsArray[]=realpath($arg);
$parsingInclude=false;
}else if($parsingOutput){$outputFileName=$arg;
$parsingOutput=false;
}else if($parsingIgnore){$options->preprocessorIgnoredFileNameArray[]=$arg;
$parsingIgnore=false;
}else if('-I'===$arg){assert(!$parsingOutput);
assert(!$parsingIgnore);
$parsingInclude=true;
}else if('-g'===$arg){assert(!$parsingOutput);
assert(!$parsingInclude);
$parsingIgnore=true;
}else if('-o'===$arg){assert(!$parsingInclude);
assert(!$parsingIgnore);
$parsingOutput=true;
}else if('--preprocess'===$arg){$options->preprocessOnly=true;
}else if('--strip'===$arg){$options->preprocessOnly=false;
$options->stripOnly=true;
}else if('--parser'===$arg){$options->preprocessOnly=false;
$options->stripOnly=false;
$path=$argv[$i+1];
$grammarFilePath=realpath($path);
if(false!==$grammarFilePath){$options->parserGrammarFilePath=$grammarFilePath;
}else{echo"Grammar file path (\"$path\") invalid\n";
exit(1);
}}else if('--testLexer'===$arg){$options->testLexer=true;
$options->preprocessOnly=false;
$options->stripOnly=false;
}else if('--symbolTable'===$arg){$options->preprocessOnly=false;
$options->stripOnly=false;
$options->symbolTableReportPath=$argv[$i+1];
}else if('--deadCode'===$arg){$options->preprocessOnly=false;
$options->stripOnly=false;
$options->eliminateDeadCode=true;
}else{$inputFilePath=realPath($arg);
}}return array($inputFilePath,$outputFileName);
}$options=new OA_CompilerOptions();
$grammarFilePath=realpath(dirname($argv[0]).'/grammar.xml');
if(false!==$grammarFilePath){$options->parserGrammarFilePath=$grammarFilePath;
}list($inputFilePath,$outputFileName)=parseCommandLine($options,$argc,$argv);
if(null!==$inputFilePath){$compiler=new OA_PhpCompiler($options);
$compiler->compile($inputFilePath,$outputFileName);
}else{echo"Usage:  p2pc.php [-I include/path]* [-g ignored_file]* [-o output_file] [--preprocess] [--strip] [--parser <grammar.xml>] [--symbolTable <symbol_table_output>] [--testLexer] input_file\n";
}
?>
